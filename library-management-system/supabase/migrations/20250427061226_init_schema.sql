-- Reset schema and apply full database structure
DROP SCHEMA IF EXISTS public CASCADE;
CREATE SCHEMA public;


-- Grant necessary permissions
ALTER SCHEMA public OWNER TO postgres;
GRANT ALL ON SCHEMA public TO postgres;
GRANT USAGE ON SCHEMA public TO postgres;
GRANT ALL ON ALL TABLES IN SCHEMA public TO postgres;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO postgres;
GRANT ALL ON ALL FUNCTIONS IN SCHEMA public TO postgres;

/*======================================================================
 Tech Titans  —  Library Management System
 Physical Schema  (Supabase/PostgreSQL 15)
 Author(s): Suhaan Syed, Siddh Bharucha, Bhavik Goplani, Alexis Vielma, Vy Luu, Fatima Avila
 -----------------------------------------------------------------------
  • Creates all enum types
  • Creates tables with keys, checks, and comments
  • Adds triggers for
        – setting item availability
        – enforcing member borrow-limit
        – calculating late fees
 ======================================================================*/

-- ───────────────────────── ENUM TYPES ─────────────────────────
CREATE TYPE membership_status_t      AS ENUM ('Active','Suspended','Overdue');
CREATE TYPE membership_type_name_t   AS ENUM ('Regular','Student','Senior Citizen');
CREATE TYPE item_type_t              AS ENUM ('Book','Digital Media','Magazine');
CREATE TYPE avail_status_t           AS ENUM ('Available','On Loan','Reserved');
CREATE TYPE media_format_t           AS ENUM ('eBook','Audiobook','Video','Other');
CREATE TYPE staff_role_t             AS ENUM ('Librarian','Administrator');
CREATE TYPE notification_type_t      AS ENUM ('Reservation','Due Date Alert','Overdue Alert');

-- ───────────────────────── LOOKUP TABLES ──────────────────────
CREATE TABLE public.membership_types (
    type_id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    type_name         membership_type_name_t NOT NULL UNIQUE,
    max_borrow_limit  INT    NOT NULL CHECK (max_borrow_limit > 0),
    fine_rate         NUMERIC(5,2) NOT NULL CHECK (fine_rate >= 0)
);

-- ───────────────────────── CORE ENTITIES ──────────────────────
CREATE TABLE public.members (
    member_id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name              TEXT NOT NULL,
    contact_info      TEXT,
    membership_type_id BIGINT
        REFERENCES membership_types(type_id) ON UPDATE CASCADE,
    account_status    membership_status_t NOT NULL DEFAULT 'Active'
);

CREATE TABLE public.library_items (
    item_id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title             TEXT NOT NULL,
    item_type         item_type_t NOT NULL,
    availability_status avail_status_t NOT NULL DEFAULT 'Available'
);

-- ─────────── “INHERITANCE” SUB-TYPE TABLES  ───────────
CREATE TABLE public.books (
    book_id           BIGINT PRIMARY KEY
        REFERENCES library_items(item_id) ON DELETE CASCADE,
    isbn              TEXT UNIQUE NOT NULL,
    author            TEXT NOT NULL,
    genre             TEXT,
    publication_year  SMALLINT
);

CREATE TABLE public.digital_media (
    media_id          BIGINT PRIMARY KEY
        REFERENCES library_items(item_id) ON DELETE CASCADE,
    creator           TEXT NOT NULL,
    format            media_format_t NOT NULL
);

CREATE TABLE public.magazines (
    magazine_id       BIGINT PRIMARY KEY
        REFERENCES library_items(item_id) ON DELETE CASCADE,
    issue_number      INT  NOT NULL UNIQUE,
    publication_date  DATE NOT NULL
);

CREATE TABLE public.staff (
    staff_id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name              TEXT NOT NULL,
    role              staff_role_t NOT NULL,
    contact_info      TEXT NOT NULL
);

-- ───────────────────────── TRANSACTIONS ───────────────────────
CREATE TABLE public.borrowing_transactions (
    borrow_id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    member_id         BIGINT NOT NULL
        REFERENCES members(member_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    item_id           BIGINT NOT NULL
        REFERENCES library_items(item_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    staff_id          BIGINT
        REFERENCES staff(staff_id) ON UPDATE CASCADE ON DELETE SET NULL,
    borrow_date       DATE NOT NULL,
    due_date          DATE NOT NULL,
    return_date       DATE,
    fine_incurred     NUMERIC(5,2) CHECK (fine_incurred IS NULL OR fine_incurred >= 0)
);

CREATE TABLE public.reservations (
    reservation_id    BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    member_id         BIGINT NOT NULL
        REFERENCES members(member_id),
    item_id           BIGINT NOT NULL
        REFERENCES library_items(item_id),
    reservation_date  DATE NOT NULL,
    expiry_date       DATE NOT NULL
        CHECK (expiry_date >= reservation_date)
);

CREATE TABLE public.payments (
    payment_id        BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    member_id         BIGINT NOT NULL
        REFERENCES members(member_id),
    amount_paid       NUMERIC(7,2) NOT NULL CHECK (amount_paid >= 0),
    payment_date      DATE NOT NULL
);

CREATE TABLE public.notifications (
    notification_id   BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    member_id         BIGINT NOT NULL
        REFERENCES members(member_id),
    notification_date TIMESTAMPTZ NOT NULL DEFAULT now(),
    notification_type notification_type_t NOT NULL
);

-- ───────────────────────── TRIGGER FUNCTIONS ──────────────────
/* 1. When an item is borrowed, mark it On Loan */
CREATE OR REPLACE FUNCTION trg_set_item_on_loan()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
    UPDATE library_items
       SET availability_status = 'On Loan'
     WHERE item_id = NEW.item_id;
    RETURN NEW;
END; $$;

/* 2. When return_date first set, mark item Available */
CREATE OR REPLACE FUNCTION trg_return_item_available()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
    IF NEW.return_date IS NOT NULL AND OLD.return_date IS NULL THEN
        UPDATE library_items
           SET availability_status = 'Available'
         WHERE item_id = NEW.item_id;
    END IF;
    RETURN NEW;
END; $$;

/* 3. Enforce member borrow-limit BEFORE insert */
CREATE OR REPLACE FUNCTION trg_check_borrow_limit()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
DECLARE
    current_loans INT;
    max_allowed   INT;
BEGIN
    SELECT COUNT(*) INTO current_loans
      FROM borrowing_transactions
     WHERE member_id = NEW.member_id
       AND return_date IS NULL;

    SELECT mt.max_borrow_limit INTO max_allowed
      FROM members m
      JOIN membership_types mt ON mt.type_id = m.membership_type_id
     WHERE m.member_id = NEW.member_id;

    IF current_loans >= COALESCE(max_allowed, 3) THEN
        RAISE EXCEPTION
          'Borrow-limit exceeded for member % (allowed %)', NEW.member_id, max_allowed;
    END IF;
    RETURN NEW;
END; $$;

/* 4. Auto-calculate fine when a return date is entered */
CREATE OR REPLACE FUNCTION trg_calc_fine()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
DECLARE
    days_late INT;
    rate      NUMERIC(5,2);
BEGIN
    IF NEW.return_date IS NOT NULL THEN
        days_late := GREATEST((NEW.return_date - NEW.due_date), 0);
        SELECT mt.fine_rate INTO rate
          FROM members m
          JOIN membership_types mt ON mt.type_id = m.membership_type_id
         WHERE m.member_id = NEW.member_id;

        NEW.fine_incurred := days_late * COALESCE(rate,0);
    END IF;
    RETURN NEW;
END; $$;

-- ───────────────────────── TRIGGERS ───────────────────────────
CREATE TRIGGER after_borrow_set_on_loan
AFTER INSERT ON borrowing_transactions
FOR EACH ROW EXECUTE FUNCTION trg_set_item_on_loan();

CREATE TRIGGER after_update_return_date
AFTER UPDATE OF return_date ON borrowing_transactions
FOR EACH ROW EXECUTE FUNCTION trg_return_item_available();

CREATE TRIGGER before_borrow_enforce_limit
BEFORE INSERT ON borrowing_transactions
FOR EACH ROW EXECUTE FUNCTION trg_check_borrow_limit();

CREATE TRIGGER before_update_calc_fine
BEFORE UPDATE OF return_date ON borrowing_transactions
FOR EACH ROW EXECUTE FUNCTION trg_calc_fine();

-- ───────────────────────── END OF FILE ────────────────────────
